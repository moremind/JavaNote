# Spring事务传播原理

## Spring事务的配置原理

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.springframework.org/schema/beans 
						http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
						http://www.springframework.org/schema/tx 
						http://www.springframework.org/schema/tx/spring-tx-4.3.xsd
						http://www.springframework.org/schema/aop 
						http://www.springframework.org/schema/aop/spring-aop-4.3.xsd">
	<aop:aspectj-autoproxy proxy-target-class="true"/>
	
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>

	<!-- 配置事务通知属性 -->
	<tx:advice id="transactionAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="add*" propagation="REQUIRED" rollback-for="Exception,RuntimeException,SQLException"/>
			<tx:method name="remove*" propagation="REQUIRED" rollback-for="Exception,RuntimeException,SQLException"/>
			<tx:method name="edit*" propagation="REQUIRED" rollback-for="Exception,RuntimeException,SQLException"/>
			<tx:method name="login" propagation="NOT_SUPPORTED"/>
			<tx:method name="query*" read-only="true"/>
		</tx:attributes>
	</tx:advice>

	<aop:config>
		<aop:advisor advice-ref="transactionAdvice" pointcut-ref="transactionPointcut"/>
        <aop:aspect ref="dataSource">
            <aop:pointcut id="transactionPointcut" expression="execution(public * com.gupaoedu..*.service..*Service.*(..))" />
        </aop:aspect>
    </aop:config>
	
</beans>
```

Spring 事务管理基于 AOP 来实现，主要是统一封装非功能性需求。

##  数据库事务原理详解

### 1、事务基本概念 

事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。 

特点：事务是恢复和并发控制的基本单位。

事务应该具有 4 个属性：原子性、一致性、 隔离性、持久性。这四个属性通常称为 ACID 特性。 

原子性（Automicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要 么都做，要么都不做。 

一致性（Consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。 一致性与原子性是密切相关的。 

隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及 使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 

 持久性（Durability）：持久性也称永久性（Permanence），指一个事务一旦提交，它 对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何 影响。

### 2、事务的基本原理

1、获取连接 Connection con = DriverManager.getConnection() 

2、开启事务 con.setAutoCommit(true/false); 

3、执行 CRUD 

4、提交事务/回滚事务 con.commit() / con.rollback(); 5、关闭连接 conn.close();

使用 Spring 的事务管理功能后，我们可以不再写步骤 2 和 4 的代码，而是由 Spirng 自 动完成。 那么 Spring 是如何在我们书写的 CRUD 之前和之后开启事务和关闭事务的 呢？解决这个问题，也就可以从整体上理解 Spring 的事务管理实现原理了。下面简单地 介绍下，注解方式为例子 配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional 标识。 Spring 在启动的时候会去解析生成相关的 bean，这时候会查看拥有相关注解的类和方 法，并且为这些类和方法生成代理，并根据@Transaction 的相关参数进行相关配置注入， 这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。 真正的数据库层的事务提交和回滚是通过 binlog 或者 redo log 实现的。

### 3、事务传播属性

![image-20220222004721296](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220222004721296.png)

### 4、数据库事务的隔离级别

![image-20220222005533003](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220222005533003.png)

脏读：一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如 果第一个事务这时候回滚了，那么第二个事务就读到了脏数据。

不可重复读：一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一 个事务对数据进行了修改，这时候两次读取的数据是不一致的。

 幻读：第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数 据，这时候第一个事务就会丢失对新增数据的修改。

总结：

隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。 大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle 少数数据库默认隔离级别为：Repeatable Read 比如： MySQL InnoDB

### 5、Spring 中的隔离级别

![image-20220222010235992](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220222010235992.png)

