# Sharding-JDBC



## 1 架构与核心概念

### 1.3 基本特性

### 1.4 架构

### 1.5 功能

#### 1.5.1 数据分片

#### 1.5.2 分布式事务

### 1.6 核心概念

#### 1.6.1 主要概念

#### 1.6.2 动态表

#### 1.6.3 广播表

#### 1.6.4 绑定表

### 1.7 使用规范

## 2 Sharding-JDBC 实战

### 2.1 引入依赖

### 2.2 原生 JDBC 使用

### 2.3 Spring 中使用

因为我们要使用 Sharding-JDBC 去访问数据库，所以我们不再使用 ORM 框架或者容器去定义数据源，而是注入 Sharding-JDBC 自定义的数据源，这样才 能保证动态选择数据源的实现。 

第二个，因为 Sharding-JDBC 是工作在客户端的，所以我们要在客户端配置分库分 表的策略。跟 Mycat 不一样的是，Sharding-JDBC 没有内置各种分片策略和算法，需要 我们通过表达式或者自定义的配置文件实现。我们创建的数据源中包含了分片的策略。 

总体上，需要配置的就是这两个，数据源和分片策略，当然分片策略又包括分库的策略和分表的策略。

#### 2.3.1 Java 配置

#### 2.3.2 Spring Boot 配置

#### 2.3.3 yml 配置

### 2.4 Spring 案例验证（gupao-shard-prop 工程）

#### 2.4.1 取模分片

### 2.4.2 绑定表

#### 2.4.3 广播表

## 4 分布式事务（shard-gupao-yml）

### 4.1 事务概述

###  4.2 两阶段事务-XA

### 4.3 柔性事务 Sage

### 4.4 柔性事务Seata

## 5 分布式全局 ID（shard-gupao-yml)

## 6 Sharding-JDBC 工作流程

![image-20220307233703735](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220307233703735.png)

### 6.1 SQL 解析

SQL 解析主要是词法和语法的解析。目前常见的 SQL 解析器主要有 fdb，jsqlparser 和 Druid。Sharding-JDBC1.4.x 之前的版本使用 Druid 作为 SQL 解析器。从 1.5.x 版本 开始，Sharding-JDBC 采用完全自研的 SQL 解析引擎。

### 6.2 SQL路由

![image-20220307233743837](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220307233743837.png)

SQL 路由是根据分片规则配置以及解析上下文中的分片条件，将 SQL 定位至真正的数 据源。它又分为直接路由、简单路由和笛卡尔积路由。 

直接路由，使用 Hint 方式。 

Binding 表是指使用同样的分片键和分片规则的一组表，也就是说任何情况下， Binding 表的分片结果应与主表一致。例如：order 表和 order_item 表，都根据 order_id 分片，结果应是 order_1 与 order_item_1 成对出现。这样的关联查询和单表查询复杂度和性能相当。如果分片条件不是等于，而是 BETWEEN 或 IN，则路由结果不一定落入单库 （表），因此一条逻辑 SQL 最终可能拆分为多条 SQL 语句。

笛卡尔积查询最为复杂，因为无法根据 Binding 关系定位分片规则的一致性，所以非 Binding 表的关联查询需要拆解为笛卡尔积组合执行。查询性能较低，而且数据库连接数 较高，需谨慎使用。
