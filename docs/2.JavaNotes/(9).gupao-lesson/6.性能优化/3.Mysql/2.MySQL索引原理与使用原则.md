# 索引

## 1.索引是什么？

### 1.1 索引是什么

#### 1.1.1 索引图解

![image-20220308170758448](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308170758448.png)

#### 1.1.2.索引类型

创建索引

![image-20220308170951469](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308170951469.png)

第一个是索引的名称，第二个是索引的列，比如我们是要对 id 创建索引还是对 name 创建索引。后面两个很重要，一个叫索引类型。

在 InnoDB 里面，索引类型有三种，普通索引、唯一索引（主键索引是特殊的唯一 索引）、全文索引。 

普通（Normal）：也叫非唯一索引，是最普通的索引，没有任何的限制。 

唯一（Unique）：唯一索引要求键值不能重复。另外需要注意的是，主键索引是一 种特殊的唯一索引，它还多了一个限制条件，要求键值不能为空。主键索引用 primay key 创建。 

全文（Fulltext）：针对比较大的数据，比如我们存放的是消息内容，有几 KB 的数 据的这种情况，如果要解决 like 查询效率低的问题，可以创建全文索引。只有文本类型 的字段才可以创建全文索引，比如 char、varchar、text。

## 2.索引存储模型推演

### 2.1. 二分查找

### 2.2. 二叉查找树（BST Binary Search Tree）

### 2.3. 平衡二叉树（AVL Tree）（左旋、右旋）

#### 2.3.1.InnoDB 逻辑存储结构

MySQL 的存储结构分为 5 级：表空间、段、簇、页、行。

![image-20220308173028712](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308173028712.png)

##### 表空间 Table Space

表空间可以看做是 InnoDB 存储引擎逻辑结构的 最高层，所有的数据都存放在表空间中。分为：系统表空间、独占表空间、通用表空间、 临时表空间、Undo 表空间。

##### 段 Segment

表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等，段是一个逻辑 的概念。一个 ibd 文件（独立表空间文件）里面会由很多个段组成。 

创建一个索引会创建两个段，一个是索引段：leaf node segment，一个是数据段： non-leaf node segment。索引段管理非叶子节点的数据。数据段管理叶子节点的数据。 也就是说，一个表的段数，就是索引的个数乘以 2。

##### 簇 Extent

一个段（Segment）又由很多的簇（也可以叫区）组成，每个区的大小是 1MB（64 个连续的页）。 

每一个段至少会有一个簇，一个段所管理的空间大小是无限的，可以一直扩展下去， 但是扩展的最小单位就是簇。

##### 页 Page

为了高效管理物理空间，对簇进一步细分，就得到了页。簇是由连续的页（Page） 组成的空间，一个簇中有 64 个连续的页。 （1MB／16KB=64）。这些页面在物理上和 逻辑上都是连续的。 

跟大多数数据库一样，InnoDB 也有页的概念（也可以称为块），每个页默认 16KB。 页是 InnoDB 存储引擎磁盘管理的最小单位，通过 innodb_page_size 设置。 

一个表空间最多拥有 2^32 个页，默认情况下一个页的大小为 16KB，也就是说一个 表空间最多存储 64TB 的数据。

操作系统和内存打交道，最小的单位是页 Page。文件系统的内存页通常是 4K

![image-20220308174135514](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308174135514.png)

```sql
SHOW VARIABLES LIKE 'innodb_page_size';
```

大小16384.

##### 行 Row

InnoDB 存储引擎是面向行的（row-oriented），也就是说数据的存放按行进行存 放。

Antelope是 InnoDB 内置的文件格式，有两种行格：

REDUNANT ROW FORMAT

COMPACT Row Format

Barracuda是 InnoDB Plugin 支持的文件格式，新增了两种行格式：

DYNAMIC ROW Format

COMPRESSED Row Format

![image-20220308212523175](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308212523175.png)

innodb_file_format 在配置文件中指定；row_format 则在创建数据表时指定。

```sql
show variables like "%innodb_file_format%";
SET GLOBAL innodb_file_format=Barracuda;
```



在创建表的时候可以指定行格式。

```sql
CREATE TABLE tf1
(c1 INT PRIMARY KEY)
ROW_FORMAT=COMPRESSED
KEY_BLOCK_SIZE=8;
```

#### 2.3.2.AVL 树用于存储索引数据

首先，索引的数据，是放在硬盘上的。查看数据和索引的大小：

当我们用树的结构来存储索引的时候，访问一个节点就要跟磁盘之间发生一次 IO。 InnoDB 操作磁盘的最小的单位是一页（或者叫一个磁盘块），大小是 16K(16384 字节)。

**那么，一个树的节点就是 16K 的大小。**

如果我们一个节点只存一个键值+数据+引用，例如整形的字段，可能只用了十几个 或者几十个字节，它远远达不到 16K 的容量，所以访问一个树节点，进行一次 IO 的时候， 浪费了大量的空间。 

所以如果每个节点存储的数据太少，从索引中找到我们需要的数据，就要访问更多 的节点，意味着跟磁盘交互次数就会过多。 

如果是机械硬盘时代，每次从磁盘读取数据需要 10ms 左右的寻址时间，交互次数 越多，消耗的时间就越多。

![image-20220308213916124](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308213916124.png)

如果要查询id=37的数据，这个时候需要跟磁盘交互3次。如果有百万数据，如何解决？

第一个就是让每个节点存储更多的数据。 

第二个，节点上的关键字的数量越多，我们的指针数也越多，也就是意味着可以有 更多的分叉（我们把它叫做“路数”）。 

因为分叉数越多，树的深度就会减少（根节点是 0）。 

这样，我们的树是不是从原来的高瘦高瘦的样子，变成了矮胖矮胖的样子？ 

这个时候，我们的树就不再是二叉了，而是多叉，或者叫做多路。

### 2.4. 多路平衡查找树（B Tree）（分裂、合并）

**跟 AVL 树一样，B 树在枝节点和叶子节点存储键值、数据地址、节点引用。** 

**它有一个特点：分叉数（路数）永远比关键字数多 1。比如我们画的这棵树，每个节 点存储两个关键字，那么就会有三个指针指向三个子节点。**

![image-20220308214927498](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308214927498.png)

最大分支为3，在插入 3 的时候， 本来应该在第一个磁盘块，但是如果一个节点有三个关键字的时候，意味着有 4 个指针， 子节点会变成 4 路，所以这个时候必须进行分裂。

![image-20220308215328308](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308215328308.png)

从这个里面我们也能看到，在更新索引的时候会有大量的索引的结构的调整，所以 解释了为什么我们不要在频繁更新的列上建索引，或者为什么不要更新主键。

### 2.5. B+树（加强版多路平衡查找树）

![image-20220308215806249](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308215806249.png)

MySQL 中的 B+Tree 有几个特点：

1、它的关键字的数量是跟路数相等的； 

2、B+Tree 的根节点和枝节点中都不会存储数据，只有叶子节点才存储数据。搜索 到关键字不会直接返回，会到最后一层的叶子节点。比如我们搜索 id=28，虽然在第一 层直接命中了，但是全部的数据在叶子节点上面，所以我还要继续往下搜索，一直到叶 子节点。

假设索引字段是 bigint 类型，长度为 8 字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。非叶子节点（一页）可以存储 16384/14=1170 个这样的 单元（键值+指针），代表有 1170 个指针。 

树 深 度 为 2 的 时 候 ， 有 1170^2 个 叶 子 节 点 ， 可 以 存 储 的 数 据 为 1170*1170*16=21902400。

![image-20220308221504363](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308221504363.png)

在查找数据时一次页的查找代表一次 IO，也就是说，一张 2000 万左右的表，查询 数据最多需要访问 3 次磁盘。 

所以在 InnoDB 中 B+ 树深度一般为 1-3 层，它就能满足千万级的数据存储。

3、B+Tree 的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个数 据会指向下一个叶子节点的第一个数据，形成了一个有序链表的结构。

4、它是根据左闭右开的区间 [ )来检索数据。

总结一下，InnoDB 中的 B+Tree 的特点： 

1）它是 B Tree 的变种，B Tree 能解决的问题，它都能解决。B Tree 解决的两大问题 是什么？（每个节点存储更多关键字；路数更多） 

2）扫库、扫表能力更强（如果我们要对表进行全表扫描，只需要遍历叶子节点就可以 了，不需要遍历整棵 B+Tree 拿到所有的数据）

3）B+Tree 的磁盘读写能力相对于 B Tree 来说更强（根节点和枝节点不保存数据区， 所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多） 

4）排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表） 

5）效率更加稳定（B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的）

#### 2.6. 为什么不用红黑树？

红黑树也是 BST 树，但是不是严格平衡的。 

必须满足 5 个约束： 

1、节点分为红色或者黑色。 

2、根节点必须是黑色的。 

3、叶子节点都是黑色的 NULL 节点。 

4、红色节点的两个子节点都是黑色（不允许两个相邻的红色节点）。 

5、从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点。

**为什么不用红黑树？1、只有两路；2、不够平衡。** 

**红黑树一般只放在内存里面用。例如 Java 的 TreeMap。**

#### 2.7. 索引方式：真的是用的 B+Tree 吗？

在 Navicat 的工具中，创建索引，索引方式有两种，Hash 和 B Tree。 

HASH：以 KV 的形式检索数据，也就是说，它会根据索引字段生成哈希码和指针， 指针指向数据。

![image-20220308222212206](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308222212206.png)

哈希索引有什么特点呢？

第一个，它的时间复杂度是 O(1)，查询速度比较快。因为哈希索引里面的数据不是 按顺序存储的，所以不能用于排序。 

第二个，我们在查询数据的时候要根据键值计算哈希码，所以它只能支持等值查询 （= IN），不支持范围查询（> < >= <= between and）。 

另外一个就是如果字段重复值很多的时候，会出现大量的哈希冲突（采用拉链法解 决），效率会降低。

**问题： InnoDB 可以在客户端创建一个索引，使用哈希索引吗？**

InnoDB 内部使用哈希索引来实现自适应哈希索引特性。

InnoDB 会自动建立自适应 Hash 索引，也就是在 B+Tree 索引基础上建立 Hash 索引， 这个过程对于客户端是不可控制的，隐式的。

## 3.B+Tree 落地形式

### 3.1. MySQL 架构

### 3.2. MySQL 数据存储文件

#### 3.2.1.MyISAM

#### 3.2.2.InnoDB

InnoDB 只有一个文件（.ibd 文件），那索引放在哪里呢？ 

在 InnoDB 里面，它是以主键为索引来组织数据的存储的，所以索引文件和数据文 件是同一个文件，都在.ibd 文件里面。

在 InnoDB 的主键索引的叶子节点上，它直接存储了我们的数据。

![image-20220308222811085](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308222811085.png)

什么叫做聚集索引（聚簇索引）？

**就是索引键值的逻辑顺序跟表数据行的物理存储顺序是一致的。（比如字典的目录 是按拼音排序的，内容也是按拼音排序的，按拼音排序的这种目录就叫聚集索引）。** 

**在 InnoDB 里面，它组织数据的方式叫做叫做（聚集）索引组织表（clustered index organize table），所以主键索引是聚集索引，非主键都是非聚集索引。**

主键之外的索引，比如我们在 name 字段 上面建的普通索引，又是怎么存储和检索数据的呢？

![image-20220308222953906](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308222953906.png)

InnoDB 中，主键索引和辅助索引是有一个主次之分的。 

辅助索引存储的是辅助索引和主键值。如果使用辅助索引查询，会根据主键值在主 键索引中查询，最终取得数据。

一张表没有主键怎么办？

**1、如果我们定义了主键(PRIMARY KEY)，那么 InnoDB 会选择主键作为聚集索引。** 

**2、如果没有显式定义主键，则 InnoDB 会选择第一个不包含有 NULL 值的唯一索引作为主键索引。** 

**3、如果也没有这样的唯一索引，则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐 藏的聚集索引，它会随着行记录的写入而主键递增**

## 4.索引使用原则

### 4.1. 列的离散（sàn）度

第一个叫做列的离散度，我们先来看一下列的离散度的公式： 

count(distinct(column_name)) : count(*)，列的全部不同值和所有数据行的比例。 数据行数相同的情况下，分子越大，列的离散度就越高。

### 4.2. 联合索引最左匹配

联合索引在 B+Tree 中是复合的数据结构，它是按照从左到右的顺序来建立搜索树的 （name 在左边，phone 在右边）。

#### 4.2.1.什么时候用到联合索引

1）使用两个字段，可以用到联合索引：

2）使用左边的 name 字段，可以用到联合索引：

3）使用右边的 phone 字段，无法使用索引，全表扫描

#### 4.2.2.如何创建联合索引

相当于建立了两个联合索引(name),(name,phone)。 

如果我们创建三个字段的索引 index(a,b,c)，相当于创建三个索引：

index(a)

index(a,b) 

index(a,b,c)

用 where b=? 和 where b=? and c=? 和 where a=? and c=?是不能使用到索引 的。不能不用第一个字段，不能中断。

### 4.3. 覆盖索引

回表： 

非主键索引，我们先通过索引找到主键索引的键值，再通过主键值查出索引里面没 有的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。

![image-20220308224044307](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308224044307.png)

在辅助索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用从索引 中就能够取得，不必从数据区中读取，这时候使用的索引就叫做覆盖索引，这样就避免 了回表。

### 4.4. 索引条件下推（ICP）

关闭ICP：

```sql
set optimizer_switch='index_condition_pushdown=off';
```

查看参数：

```sql
show variables like 'optimizer_switch';
```

```sql
select * from employees where last_name='wang' and first_name LIKE '%zi';
```

这条 SQL 有两种执行方式:

1、根据联合索引查出所有姓 wang 的二级索引数据，然后回表，到主键索引上查询 全部符合条件的数据（3 条数据）。然后返回给 Server 层，在 Server 层过滤出名字以 zi 结尾的员工。 

2、根据联合索引查出所有姓 wang 的二级索引数据（3 个索引），然后从二级索引 中筛选出 first_name 以 zi 结尾的索引（1 个索引），然后再回表，到主键索引上查询全 部符合条件的数据（1 条数据），返回给 Server 层。

![image-20220308224254532](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220308224254532.png)

很明显，第二种方式到主键索引上查询的数据更少。 

注意，索引的比较是在存储引擎进行的，数据记录的比较，是在 Server 层进行的。 而当 first_name 的条件不能用于索引过滤时，Server 层不会把 first_name 的条件传递 给存储引擎，所以读取了两条没有必要的记录。

开启 ICP：

```sql
set optimizer_switch='index_condition_pushdown=on';
```

索引条件下推（Index Condition Pushdown），5.6 以后完善的功能。只适用于二 级索引。ICP 的目标是减少访问表的完整行的读数量从而减少 I/O 操作

## 5.索引的创建与使用

### 5.1. 索引的创建

1、在用于 where 判断 order 排序和 join 的（on）字段上创建索引 

2、索引的个数不要过多——浪费空间，更新变慢。 

3、区分度低的字段，例如性别，不要建索引。 ——离散度太低，导致扫描行数过多。 

4、频繁更新的值，不要作为主键或者索引。 ——页分裂 

5、组合索引把散列性高（区分度高）的值放在前面。 

6、创建复合索引，而不是修改单列索引。 

7、过长的字段，怎么建立索引？ 

8、为什么不建议用无序的值（例如身份证、UUID ）作为索引？

### 5.2. 什么时候用不到索引？

1、索引列上使用函数（replace\SUBSTR\CONCAT\sum count avg）、表达式、 计算（+ - * /）：

```sql
explain SELECT * FROM `t2` where id+1 = 4;
```

2、字符串不加引号，出现隐式转换

```sql
ALTER TABLE user_innodb DROP INDEX comidx_name_phone;
ALTER TABLE user_innodb add INDEX comidx_name_phone (name,phone);
```

```sql
explain SELECT * FROM `user_innodb` where name = 136;
explain SELECT * FROM `user_innodb` where name = '136';
```

3、like 条件中前面带%

where 条件中 like abc%，like %2673%，like %888 都用不到索引吗？为什么？

```sql
explain select *from user_innodb where name like 'wang%';
explain select *from user_innodb where name like '%wang';
```

过滤的开销太大，所以无法使用索引。这个时候可以用全文索引。

4、负向查询 

NOT LIKE 不能

```sql
explain select *from employees where last_name not like 'wang'
```

!= （<>）和 NOT IN 在某些情况下可以：

```sql
explain select *from employees where emp_no not in (1)
explain select *from employees where emp_no <> 1
```

**注意一个 SQL 语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。** 

**其实，用不用索引，最终都是优化器说了算。** 

优化器是基于什么的优化器？ 

**基于 cost 开销（Cost Base Optimizer），它不是基于规则（Rule-Based Optimizer）， 也不是基于语义。怎么样开销小就怎么来。**
