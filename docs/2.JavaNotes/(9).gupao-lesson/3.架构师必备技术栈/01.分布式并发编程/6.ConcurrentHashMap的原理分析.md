# ConcurrentHashMap源码

## JDK1.7 和 Jdk1.8 版本的变化

在 JDK1.7 的 实 现 上 ， ConrruentHashMap 由一个个 Segment 组 成 ， 简 单 来 说 ， ConcurrentHashMap 是一个 Segment 数组，它通过继承 ReentrantLock 来进行加锁，通过 每次锁住一个 segment 来保证每个 segment 内的操作的线程安全性从而实现全局线程安全。

![image-20220302224620179](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220302224620179.png)

### 1.8改进

1.取消了 segment 分段设计，直接使用 Node 数组来保存数据，并且采用 Node 数组元素作 为锁来实现每一行数据进行加锁来进一步减少并发冲突的概率 

2.将原本数组+单向链表的数据结构变更为了数组+单向链表+红黑树的结构。为什么要引入 红黑树呢？在正常情况下，key hash 之后如果能够很均匀的分散在数组中，那么 table 数 组中的每个队列的长度主要为 0 或者 1.但是实际情况下，还是会存在一些队列长度过长的 情况。如果还采用单向列表方式，那么查询某个节点的时间复杂度就变为 O(n); 因此对于 队列长度超过 8 的列表，**JDK1.8 采用了红黑树的结构，那么查询的时间复杂度就会降低到 O(logN)**,可以提升查找的性能；

## put第一阶段

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}
```

```java
final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh >= 0) {
                            binCount = 1;
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }
```

### initTable

sizeCtl：

-1 代表正在初始化

-N 代表有N-1有二个线程正在进行扩容操作

0标识Node数组还没有初始化，正数代表初始化或者下一次扩容大小

```java
private final Node<K,V>[] initTable() {
        Node<K,V>[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) {
            if ((sc = sizeCtl) < 0) //被其他线程抢占了初始化的操作,则直接让出自己的 CPU时间片
                Thread.yield(); // lost initialization race; just spin
            //被其他线程抢占了初始化的操作,则直接让出自己的 CPU时间片
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if ((tab = table) == null || tab.length == 0) {
                        // 默认长度是16
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings("unchecked")
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        table = tab = nt; // 将黑哥数组赋值给table
                        sc = n - (n >>> 2); // 计算下次扩容大小，实际就是当前容量的0.75倍
                    }
                } finally {
                    // 
                    sizeCtl = sc; // sizeCtl = n*0.75 = 12
                }
                break;
            }
        }
        return tab;
    }
```

sizeCtl = n*0.75 = 12表示下次扩容大小

### tabAt

getObjectVolatile，一旦看到 volatile 关键字，就表示可见性。因为对 volatile 写操作 happenbefore 于 volatile 读操作，因此其他线程对 table 的修改均对 get 读取可见； 

虽然 table 数组本身是增加了 volatile 属性，但是“**volatile 的数组只针对数组的引用具有 volatile 的语义，而不是它的元素**”。 所以如果有其他线程对这个数组的元素进行写操作，那 么当前线程来读的时候不一定能读到最新的值。

```java
    static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {
        return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);
    }
```

### 图解分析

![image-20220302232741847](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220302232741847.png)

## put第二阶段

在putVal方法执行完成以后，会通过addCount来增加ConcurrentHashMap中的元素个数， 并且还会可能触发扩容操作。这里会有两个非常经典的设计 

1.高并发下的扩容

2.如何保证 addCount 的数据安全性以及性能

### addCount():计数

```java
addCount(1L, binCount);
```

如何保证并发的size更新的安全性->原子性

1.cas => 加锁 性能下降，不断cas，自旋

2.分治

```java
private final void addCount(long x, int check) {
        CounterCell[] as; long b, s;
    	// 判断 counterCells 是否为空，
        // 1. 如果为空，就通过 cas 操作尝试修改 baseCount 变量，对这个变量进行原子累加操作(做这个操作的意义是：如果在没有竞争的情况下，仍然采用 baseCount 来记录元素个数)
        // 2. 如果 cas 失败说明存在竞争，这个时候不能再采用 baseCount 来累加，而是通过CounterCell 来记录
        if ((as = counterCells) != null ||
            !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
            CounterCell a; long v; int m;
            boolean uncontended = true;
           // 这里有几个判断
//1. 计数表为空则直接调用 fullAddCount
//2. 从计数表中随机取出一个数组的位置为空，直接调用 fullAddCount
//3. 通过 CAS 修改 CounterCell 随机位置的值，如果修改失败说明出现并发情况（这里又用到了一种巧妙的方法），调用 fullAndCountRandom 在线程并发的时候会有性能问题以及可能会产生相同的随机数,ThreadLocalRandom.getProbe 可以解决这个问题，并且性能要比 Random 高
            if (as == null || (m = as.length - 1) < 0 ||
                (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
                !(uncontended =
                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
                fullAddCount(x, uncontended);
                return;
            }
            if (check <= 1) //链表长度小于等于 1，不需要考虑扩容
                return;
            s = sumCount(); // 统计ConcurrentHashMap元素个数
        }
        ...
    }
```

baseCount=0：用来记录元素个数的成员属性 => 传入值baseCount = 1

ThreadLocalRandom => 线程安全的生成随机数

### CounterCell解释

```java
	private transient volatile int cellsBusy; // 标识当前 cell 数组是否在初始化或扩容中的CAS 标志位

    /**
     * Table of counter cells. When non-null, size is a power of 2.
     */
    private transient volatile CounterCell[] counterCells; // counterCells 数组，总数值的分值分别存在每个 cell 中
```

```java
    @sun.misc.Contended static final class CounterCell {
        volatile long value;
        CounterCell(long x) { value = x; }
    }
//看到这段代码就能够明白了，CounterCell 数组的每个元素，都存储一个元素个数，而实际我们调用size 方法就是通过这个循环累加来得到的
//又是一个设计精华，大家可以借鉴； 有了这个前提，再会过去看 addCount 这个方法，就容易理解一些了
	final long sumCount() {
        CounterCell[] as = counterCells; CounterCell a;
        long sum = baseCount;
        if (as != null) {
            for (int i = 0; i < as.length; ++i) {
                if ((a = as[i]) != null)
                    sum += a.value;
            }
        }
        return sum;
    }
```



![image-20220302233643255](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220302233643255.png)

### fullAddCount源码

第一次进来的位置：

cellsBusy：1表示已经有其他线程在进行扩容了

第一次线程进来的时候：ThreadA进入

![image-20220302235448532](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220302235448532.png)

```java
            else if (cellsBusy == 0 && counterCells == as &&
                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                boolean init = false;
                try {                           // Initialize table
                    if (counterCells == as) {
                        // 定义长度为2的CountCell
                        CounterCell[] rs = new CounterCell[2];
                        rs[h & 1] = new CounterCell(x);
                        counterCells = rs;
                        init = true;
                    }
                } finally {
                    cellsBusy = 0;
                }
                if (init)
                    break;
            }
```

第二次线程线程进来的时候：ThreadB进入线程

![image-20220302235742080](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220302235742080.png)

```java
				if ((a = as[(n - 1) & h]) == null) {
                    if (cellsBusy == 0) {            // Try to attach new Cell
                        CounterCell r = new CounterCell(x); // Optimistic create
                        if (cellsBusy == 0 &&
                            U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                            boolean created = false;
                            try {               // Recheck under lock
                                CounterCell[] rs; int m, j;
                                if ((rs = counterCells) != null &&
                                    (m = rs.length) > 0 &&
                                    rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                cellsBusy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
```

其他线程进入：

![image-20220303000045422](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220303000045422.png)

```java
U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)
```

直接通过cas进行修改value值

```java
private final void fullAddCount(long x, boolean wasUncontended) {
        int h;
        if ((h = ThreadLocalRandom.getProbe()) == 0) {
            ThreadLocalRandom.localInit();      // force initialization
            h = ThreadLocalRandom.getProbe();
            wasUncontended = true;
        }
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            CounterCell[] as; CounterCell a; int n; long v;
            if ((as = counterCells) != null && (n = as.length) > 0) {
                if ((a = as[(n - 1) & h]) == null) {
                    if (cellsBusy == 0) {            // Try to attach new Cell
                        CounterCell r = new CounterCell(x); // Optimistic create
                        if (cellsBusy == 0 &&
                            U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                            boolean created = false;
                            try {               // Recheck under lock
                                CounterCell[] rs; int m, j;
                                if ((rs = counterCells) != null &&
                                    (m = rs.length) > 0 &&
                                    rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                cellsBusy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))
                    break;
                else if (counterCells != as || n >= NCPU)
                    collide = false;            // At max size or stale
                else if (!collide)
                    collide = true;
                else if (cellsBusy == 0 &&
                         U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                    try {
                        if (counterCells == as) {// Expand table unless stale
                            CounterCell[] rs = new CounterCell[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            counterCells = rs;
                        }
                    } finally {
                        cellsBusy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                h = ThreadLocalRandom.advanceProbe(h);
            }
            else if (cellsBusy == 0 && counterCells == as &&
                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                boolean init = false;
                try {                           // Initialize table
                    if (counterCells == as) {
                        CounterCell[] rs = new CounterCell[2];
                        rs[h & 1] = new CounterCell(x);
                        counterCells = rs;
                        init = true;
                    }
                } finally {
                    cellsBusy = 0;
                }
                if (init)
                    break;
            }
            else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))
                break;                          // Fall back on using base
        }
    }
```

### CountCells图解

![image-20220303000357790](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220303000357790.png)

## transfer扩容阶段

> ConcurrentHashMap的扩容是可以并行扩容的

判断是否需要扩容，也就是当更新后的键值对总数 baseCount >= 阈值 sizeCtl 时，进行 rehash，这里面会有两个逻辑。 

1.如果当前正在处于扩容阶段，则当前线程会加入并且协助扩容 

2.如果当前没有在扩容，则直接触发扩容操作

```java
        if (check >= 0) {//如果 binCount>=0，标识需要检查扩容
            Node<K,V>[] tab, nt; int n, sc;
            //s 标识集合大小，如果集合大小大于或等于扩容阈值（默认值的 0.75）
			//并且 table 不为空并且 table 的长度小于最大容量
            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
                   (n = tab.length) < MAXIMUM_CAPACITY) {
                int rs = resizeStamp(n); //这里是生成一个唯一的扩容戳，
                if (sc < 0) { //sc<0，也就是 sizeCtl<0，说明已经有别的线程正在扩容了
                    //这 5 个条件只要有一个条件为 true，说明当前线程不能帮助进行此次的扩容，直接跳出循环
                    //sc >>> RESIZE_STAMP_SHIFT!=rs 表示比较高 RESIZE_STAMP_BITS 位生成戳和 rs 是否相等，相同
                    //sc=rs+1 表示扩容结束
                    //sc==rs+MAX_RESIZERS 表示帮助线程线程已经达到最大值了
                    //nt=nextTable -> 表示扩容已经结束
                    //transferIndex<=0 表示所有的 transfer 任务都被领取完了，没有剩余的hash 桶来给自己自己好这个线程来做 transfer
                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                        transferIndex <= 0)
                        break;
                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) //当前线程尝试帮助此次扩容，如果成功，则调用 transfer
                        transfer(tab, nt);
                }
                // 如果当前没有在扩容，那么 rs 肯定是一个正数，通过 rs<<RESIZE_STAMP_SHIFT 将 sc 设置为一个负数，+2 表示有一个线程在执行扩容
                else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                             (rs << RESIZE_STAMP_SHIFT) + 2))
                    transfer(tab, null);
                s = sumCount(); // 重新计数，判断是否需要开启下一轮扩容
            }
        }
```

### resizeStamp

```java
static final int resizeStamp(int n) {
    return Integer.numberOfLeadingZeros(n) | (1 << (RESIZE_STAMP_BITS - 1));
}
```

### transfer



### 扩容过程图解



### sizeCtl 扩容退出机制



## 数据迁移的实现方案

## put第三阶段

## put第四阶段

```java
            else { //进入到这个分支，说明 f 是当前 nodes 数组对应位置节点的头节点，并且不为空
                V oldVal = null;
                synchronized (f) { //给对应的头结点加锁
                    if (tabAt(tab, i) == f) { {//再次判断对应下标位置是否为 f 节点
                        if (fh >= 0) { //头结点的 hash 值大于 0，说明是链表
                            binCount = 1; //用来记录链表的长度
                            for (Node<K,V> e = f;; ++binCount) { //遍历链表
                                K ek;
                                //如果发现相同的 key，则判断是否需要进行值的覆盖
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    //默认情况下，直接覆盖旧的值
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                //一直遍历到链表的最末端，直接把新的值加入到链表的最后面
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        //如果当前的 f 节点是一颗红黑树
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            //则调用红黑树的插入方法插入新的值
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;//同样，如果值已经存在，则直接替换
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
```



