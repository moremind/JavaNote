# 多线程的基本原理以及挑战

## synchronized 的基本认识

在多线程并发编程中 synchronized 一直是元老级角色，很 多人都会称呼它为重量级锁。但是，随着 Java SE 1.6 对 synchronized 进行了各种优化之后，有些情况下它就并不 那么重，Java SE 1.6 中为了减少获得锁和释放锁带来的性 能消耗而引入的偏向锁和轻量级锁。这块在后续我们会慢慢展开。

### synchronized 的基本语法

synchronized 有三种方式来加锁，分别是 

1. 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 

   ```java
   public class SyncDemo {
       public synchronized void test() {
           
       }
   }
   ```

2. 静态方法，作用于当前类对象加锁，进入同步代码前要 获得当前类对象的锁 

   ```java
   public synchronized static void test3() {      
   }
   ```

3. 修饰代码块，指定加锁对象，对给定对象加锁，进入同 步代码库前要获得给定对象的锁。 

   ```java
   public void test2() {
       synchronized (SyncDemo.class) {
           // todo
       }
   }
   ```

   2.3等价都是对象锁

不同的修饰类型，代表锁的控制粒度

### 锁在内存中是如何存储的？

#### 对象在内存中的布局

![image-20220227181239425](https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220227181239425.png)

![image-20220227181515788](https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220227181515788.png)

1.对象在内存中的布局

2.markword

无锁->｛偏向锁->轻量级锁｝-> 重量级锁（真正意义上的加锁）

假如有两个线程ThreadA/ThreadB

1.只有线程A去访问（多数情况）->偏向锁

​	1. ThreadA的ThreadId，偏向锁标记1

2.ThreadA和ThreadB交替访问->轻量级锁->自旋

3.多个线程同时访问->阻塞



## 偏向锁

CAS比较

![偏向锁](https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/%E5%81%8F%E5%90%91%E9%94%81.png)

大部分情况下，锁不仅仅不存在多线程竞争， 而是总是由同一个线程多次获得，为了让线程获取锁的代 价更低就引入了偏向锁的概念。怎么理解偏向锁呢？ 当一个线程访问加了同步锁的代码块时，会在对象头中存 储当前线程的 ID，后续这个线程进入和退出这段加了同步 锁的代码块时，不需要再次加锁和释放锁。而是直接比较 对象头里面是否存储了指向当前线程的偏向锁。如果相等 表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁 了

### 偏向锁的获取和撤销逻辑 

#### 偏向锁获取

![image-20220227222333920](https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220227222333920.png)

1.首先获取锁 对象的 Markword，判断是否处于可偏向状 态。（biased_lock=1、且 ThreadId 为空） 

2.如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID 写入到 MarkWord 

**a) 如果 cas 成功，那么 markword 就会变成这样。 表示已经获得了锁对象的偏向锁，接着执行同步代码块** 

**b) 如果 cas 失败，说明有其他线程已经获得了偏向锁， 这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁**（这个 操作需要等到全局安全点，也就是没有线程在执行字 节码）才能执行 

3.如果是已偏向状态，需要检查 markword 中存储的 ThreadID 是否等于当前线程的 ThreadID 

a) 如果相等，不需要再次获得锁，可直接执行同步代码 块 

b) 如果不相等，说明当前锁偏向于其他线程，需要撤销 偏向锁并升级到轻量级锁

#### 偏向锁撤销

偏向锁的撤销并不是把对象恢复到无锁可偏向状态（因为 偏向锁并不存在锁释放的概念），而是在获取偏向锁的过程 中，发现 cas 失败也就是存在线程竞争时，直接把被偏向 的锁对象升级到被加了轻量级锁的状态。 对原持有偏向锁的线程进行撤销时，原获得偏向锁的线程 

有两种情况： 

1.原获得偏向锁的线程如果已经退出了临界区，也就是同 步代码块执行完了，那么这个时候会把对象头设置成无 锁状态并且争抢锁的线程可以基于 CAS 重新偏向但前 线程 

2.如果原获得偏向锁的线程的同步代码块还没执行完，处 于临界区之内，这个时候会把原获得偏向锁的线程升级 为轻量级锁后继续执行同步代码块 

在我们的应用开发中，绝大部分情况下一定会存在 2 个以 上的线程竞争，那么如果开启偏向锁，反而会提升获取锁 的资源消耗。**所以可以通过 jvm 参数 UseBiasedLocking 来设置开启或关闭偏向锁**

## 轻量级锁(自旋)

前提：绝大部门线程在获得锁以后，在非常短的时间会去释放锁

### 轻量级锁的加锁和解锁逻辑

```java
for(;;;) {
    if (cas) {
        return;// 表示获得锁成功
    }
}
```

锁升级为轻量级锁之后，对象的 Markword 也会进行相应 的的变化。升级为轻量级锁的过程：

1.线程在自己的栈桢中创建锁记录 LockRecord。

2.将锁对象的对象头中的MarkWord复制到线程的刚刚创 建的锁记录中。 

3.将锁记录中的 Owner 指针指向锁对象。 

4.将锁对象的对象头的 MarkWord替换为指向锁记录的指 针。

![轻量级锁](https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png)

### 自旋锁

自旋会占用CPU资源，所以在指定的自旋次数之后，如果还没有获得轻量级锁，锁膨胀成重量级锁

轻量级锁在加锁过程中，用到了自旋锁 所谓自旋，就是指当有另外一个线程来竞争锁时，这个线 程会在原地循环等待，而不是把该线程给阻塞，直到那个 获得锁的线程释放锁之后，这个线程就可以马上获得锁的。 注意，锁在原地循环的时候，是会消耗 cpu 的，就相当于 在执行一个啥也没有的 for 循环。 

所以，**轻量级锁适用于那些同步代码块执行的很快的场景，** 这样，线程原地等待很短的时间就能够获得锁了。 自旋锁的使用，其实也是有一定的概率背景，在大部分同 步代码块执行的时间都是很短的。

所以通过看似无异议的 循环反而能提升锁的性能。 但是自旋必须要有一定的条件控制，否则如果一个线程执 行同步代码块的时间很长，那么这个线程不断的循环反而 会消耗 CPU 资源。**默认情况下自旋的次数是 10 次， 可以通过 preBlockSpin 来修改**

**在 JDK1.6 之后，引入了自适应自旋锁，自适应意味着自旋 的次数不是固定不变的，而是根据前一次在同一个锁上自 旋的时间以及锁的拥有者的状态来决定。**

如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并 且持有锁的线程正在运行中，那么虚拟机就会认为这次自 旋也是很有可能再次成功，进而它将允许自旋等待持续相 对更长的时间。如果对于某个锁，自旋很少成功获得过， 那在以后尝试获取这个锁时将可能省略掉自旋过程，直接 阻塞线程，避免浪费处理器资源

### 轻量级锁的解锁

轻量级锁的锁释放逻辑其实就是获得锁的逆向逻辑，通过 CAS 操作把线程栈帧中的 LockRecord 替换回到锁对象的 MarkWord 中，如果成功表示没有竞争。如果失败，表示 当前锁存在竞争，那么轻量级锁就会膨胀成为重量级锁

## 重量级锁

升级到重量级锁之后，没有获得锁的线程会被阻塞。->BlOCKED状态

![image-20220227225103301](https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220227225103301.png)

monitor->muxtexLock（互斥）

![image-20220227225209417](https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220227225209417.png)

## Synchronized 结合 Java Object 对象中的 wait,notify,notifyAll

### wait/notify/notifyall 基本概念

wait：表示持有对象锁的线程 A 准备释放对象锁权限，释 放 cpu 资源并进入等待状态。 

notify：表示持有对象锁的线程 A 准备释放对象锁权限，通 知 jvm 唤 醒 某 个 竞 争 该 对 象 锁 的 线 程 X 。 线 程 A  synchronized 代码执行结束并且释放了锁之后，线程 X 直 接获得对象锁权限，其他竞争线程继续等待(即使线程 X 同 步完毕，释放对象锁，其他竞争线程仍然等待，直至有新 的 notify ,notifyAll 被调用)。 

notifyAll：notifyall 和 notify 的区别在于，notifyAll 会唤醒 所有竞争同一个对象锁的所有线程，当已经获得锁的线程 A 释放锁之后，所有被唤醒的线程都有可能获得对象锁权限

### wait/notify 的基本使用

![image-20220227225502215](https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20220227225502215.png)

## 总结

偏向锁(一般关闭)->轻量锁

cas->自旋锁/自适应锁 

无锁->轻量级锁->重量级锁
