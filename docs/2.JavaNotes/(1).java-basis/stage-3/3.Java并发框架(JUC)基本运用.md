## 1.Java并发锁

### 1.1 重进入锁-ReentrantLock

* 与Synchronized的类似点
  * 互斥(Mutual Exclusion)
  * 重进入(Reentracy)
  * 隐形Monitor机制


* 与Synchronized的不通电
  * 获得顺序(公平锁和非公平锁)
  * 限时锁定(tryLock)
  * 条件对象支持(Condition Support)
  * 运维方法
```java
// 获取顺序
public class AcquireAndReleaseDemo {
    public static void main(String[] args) {
        // Lock机制
        // 获取Acquire
          // Thread 进入 synchronized -> 获得锁
        // 释放Release
          // 1.当Thread(hold lock)，调用Object#wait()时候，释放锁
          // 2.运行期间异常，Thread消亡
          // 3.Condition#await()
          // 4.Java9 自旋 Thread.onSpinWait();
          // 5.Thread park -> LockSupport.park(Object)
          // 6.Thread.yield()

        // 所谓公平(Fair) 和 非公平(NonFair)
        // 公平(Fair)线程FIFO
        // 非公平锁(NonFair)线程随线程调度,除非必要，不要调整优先级
    }
}
```

```java
// ReentrantLock
public class ReentrantLockDemo {
    public static void main(String[] args) {
        lockOpsMethods();
    }

    private static void lockOpsMethods() {
        ReentrantLock lock = new ReentrantLock();
        int count = lock.getHoldCount();
        System.out.printf("锁定之前的重进入数：%d\n", count);
        lock(lock, 10);
    }

    private static void lock(ReentrantLock lock, int times) {

        if (times < 1) {
            return;
        }
        lock.lock();
        try {
            // TODO
            lock(lock, --times);
            System.out.printf("锁定之后的重进入数：%d\n", lock.getHoldCount());
        } finally {
            lock.unlock();
        }
    }

    private static void conditionObject() {
        Lock lock = new ReentrantLock();

        // 条件变量包括条件，同时
        Condition condition = lock.newCondition();

        try {
            condition.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void tryLockInTimeout() {
        Lock lock = new ReentrantLock();
        try {
            if(lock.tryLock(300, TimeUnit.MILLISECONDS)) {
                // Lock API 语义补充了synchronized 原语的不足
                // todo add something
            }
        } catch (InterruptedException e) {
            // 重置中止状态(防止被中途清除状态)
            Thread.currentThread().interrupt();
            // logger error message
        }
    }

    private static void synchronizedStatement() {
        // 假设出现死锁或者饥饿
        synchronized (ReentrantLockDemo.class) {
            if (3 > 2) { // 条件
                // Object 线程通讯的方法
                try {
                    ReentrantLockDemo.class.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

### 1.2 重进入读写锁-ReentrantReadWriteLock

### 1.3 邮票锁-StampedLock

> https://blog.csdn.net/a18792721831/article/details/107071195

## 2.Java原子操作



## 3.Java并发限制



## 4.线程池

