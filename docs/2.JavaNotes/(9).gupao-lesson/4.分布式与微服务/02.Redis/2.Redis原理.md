# Redis原理

## 1.发布订阅模式

### 1.1 列表的局限

通过队列的 rpush 和 lpop 可以实现消息队列（队尾进队头出），但是消 费者需要不停地调用 lpop 查看 List 中是否有等待处理的消息（比如写一个 while 循环）。 为了减少通信的消耗，可以 sleep()一段时间再消费，但是会有两个问题：

1、如果生产者生产消息的速度远大于消费者消费消息的速度，List 会占用大量的内 存。 

2、消息的实时性降低。 

list 还提供了一个阻塞的命令：blpop，没有任何元素可以弹出的时候，连接会被阻塞。

基于 list 实现的消息队列，不支持一对多的消息分发。

### 1.2 发布订阅模式

#### 1.2.1订阅频道

![image-20220306181308994](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306181308994.png)

发出去的消息不会被持久化，因为它已经从队列里面移除了， 所以消费者只能收到它开始订阅这个频道之后发布的消息。

![image-20220306163537562](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306163537562.png)

#### 1.2.2 按规则订阅频道

支持 ? 和 * 占位符。?代表一个字符，*代表 0 个或者多个字

![image-20220306181608159](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306181608159.png)

![image-20220306181642540](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306181642540.png)

## 2.Redis事务

### 2.1 为什么要用事务

我们知道 Redis 的单个命令是原子性的（比如 get set mget mset），如果涉及到 多个命令的时候，需要把多个命令作为一个不可分割的处理序列，就需要用到事务。

Redis 的事务有两个特点： 

1、按进入队列的顺序执行。

2、不会受到其他客户端的请求的影响。

### 2.2 事务的用法

通过 multi 的命令开启事务。事务不能嵌套，多个 multi 命令效果一样。 

multi 执行后，客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被 执行， 而是被放到一个队列中， 当 exec 命令被调用时， 所有队列中的命令才会被执 行。

**Redis 的事务涉及到四个命令：multi（开启事务），exec（执行事务），discard （取消事务），watch（监视）**

### 2.3 watch命令

在 Redis 中还提供了一个 watch 命令。 

它可以为 Redis 事务提供 CAS 乐观锁行为（Check and Set / Compare and Swap），也就是多个线程更新变量的时候，会跟原值做比较，只有它没有被其他线程修 改的情况下，才更新成新的值。

我们可以用 watch 监视一个或者多个 key，如果开启事务之后，至少有一个被监视 key 键在 exec 执行之前被修改了， 那么整个事务都会被取消（key 提前过期除外）。可 以用 unwatch 取消。

![image-20220306183918981](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306183918981.png)

### 2.4 事务可能遇到的问题

#### 2.4.1 在执行exec之前发生错误

比如：入队的命令存在语法错误，包括参数数量，参数名等等（编译器错误）。

![image-20220306184014917](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306184014917.png)

在这种情况下事务会被拒绝执行，也就是队列中所有的命令都不会得到执行。

#### 2.4.2 在执行exec之后发生错误

比如，类型错误，比如对 String 使用了 Hash 的命令，这是一种运行时错误。

![image-20220306185223362](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306185223362.png)

最后我们发现 set k1 1 的命令是成功的，也就是在这种发生了运行时异常的情况下， 只有错误的命令没有被执行，但是其他命令没有受到影响。

 这个显然不符合我们对原子性的定义，也就是我们没办法用 Redis 的这种事务机制 来实现原子性，保证数据的一致。

## 3.lua脚本

使用 Lua 脚本来执行 Redis 命令的好处： 

1、一次发送多个命令，减少网络开销。

2、Redis 会将整个脚本作为一个整体执行，不会被其他请求打断，保持原子性。 

3、对于复杂的组合命令，我们可以放在文件中，可以实现程序之间的命令集复 用。

### 3.1 在redis中调用Lua脚本

![image-20220306185650022](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306185650022.png)

### 3.2 在Lua脚本中调用Redis命令

![image-20220306185750166](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306185750166.png)

#### 3.2.1 设置键值对

![image-20220306185818021](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306185818021.png)

#### 3.2.2 在 Redis 中调用 Lua 脚本文件中的命，操作Redis

![image-20220306185837551](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306185837551.png)

#### 3.2.3 案例：对 IP 进行限流

![image-20220306190310912](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306190310912.png)

![image-20220306190326441](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306190326441.png)

#### 3.2.4 缓存 Lua 脚

##### 为什么要缓存

在脚本比较长的情况下，如果每次调用脚本都需要把整个脚本传给 Redis 服务端， 会产生比较大的网络开销。为了解决这个问题，Redis 提供了 EVALSHA 命令，允许开发 者通过脚本内容的 SHA1 摘要来执行脚本。

##### 如何缓存

Redis 在执行 script load 命令时会计算脚本的 SHA1 摘要并记录在脚本缓存中，执 行 EVALSHA 命令时 Redis 会根据提供的摘要从脚本缓存中查找对应的脚本内容，如果 找到了则执行脚本，否则会返回错误："NOSCRIPT No matching script. Please use EVAL."

![image-20220306190511004](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306190511004.png)

##### 自乘案例

![image-20220306200859267](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306200859267.png)

#### 3.2.5 脚本超时

为 了防 止 某个 脚本 执 行时 间 过长 导 致 Redis 无 法提 供 服务 ， Redis 提 供 了 lua-time-limit 参数限制脚本的最长运行时间，默认为 5 秒钟。 

`lua-time-limit 5000`（redis.conf 配置文件中)

当脚本运行时间超过这一限制后，Redis 将开始接受其他命令但不会执行（以确保脚 本的原子性，因为此时脚本并没有被终止），而是会返回“BUSY”错误。

Redis 提供了一个 script kill 的命令来中止脚本的执行。新开一个客户端：

```shell
script kill
```

![image-20220306201058197](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306201058197.png)

shutdown nosave 和 shutdown 的区别在于 shutdown nosave 不会进行持久化 操作，意味着发生在上一次快照后的数据库修改都会丢失。

## 4.Redis为什么那么快

### 4.1 Redis 到底有多快？

根据官方的数据，Redis 的 QPS 可以达到 10 万左右

### 4.2 Redis 为什么这么快？

总结：

1）纯内存结构

2）单线程

3）多路复用

#### 4.2.1 内存

KV 结构的内存数据库，时间复杂度 O(1)。

**第二个，要实现这么高的并发性能，是不是要创建非常多的线程？ 恰恰相反，Redis 是单线程的。**

#### 4.2.2 单线程

1、没有创建线程、销毁线程带来的消耗 

2、避免了上线文切换导致的 CPU 消耗 

3、避免了线程之间带来的竞争问题，例如加锁释放锁死锁等等

#### 4.2.3 异步非阻塞

异步非阻塞 I/O，多路复用处理并连接

### 4.3 Redis 为什么是单线程的？

[FAQ – Redis](https://redis.io/topics/faq)

因为单线程已经够用了，CPU 不是 redis 的瓶颈。Redis 的瓶颈最有可能是机器内存 或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单 线程的方案了。

### 4.4 单线程为什么这么快？

#### 4.4.1 虚拟存储器（虚拟内存 Vitual Memory）

计算机主存（内存）可看作一个由 M 个连续的字节大小的单元组成的数组，每个字 节有一个唯一的地址，这个地址叫做物理地址（PA）。早期的计算机中，如果 CPU 需要 内存，使用物理寻址，直接访问主存储器。

![image-20220306202024274](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306202024274.png)

这种方式有几个弊端： 

1、在多用户多任务操作系统中，所有的进程共享主存，如果每个进程都独占一块物 理地址空间，主存很快就会被用完。我们希望在不同的时刻，不同的进程可以共用同一 块物理地址空间。 

2、如果所有进程都是直接访问物理内存，那么一个进程就可以修改其他进程的内存 数据，导致物理地址空间被破坏，程序运行就会出现异常。 

为了解决这些问题，我们就想了一个办法，在 CPU 和主存之间增加一个中间层。CPU 不再使用物理地址访问，而是访问一个虚拟地址，由这个中间层把地址转换成物理地址， 最终获得数据。这个中间层就叫做虚拟存储器（Virtual Memory）。

![image-20220306202104955](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306202104955.png)

address sizes : 40 bits physical, 48 bits virtual 

实际的物理内存可能远远小于虚拟内存的大小。 

总结：引入虚拟内存，可以提供更大的地址空间，并且地址空间是连续的，使得程 序编写、链接更加简单。并且可以对物理内存进行隔离，不同的进程操作互不影响。还 可以通过把同一块物理内存映射到不同的虚拟地址空间实现内存共享。

#### 4.4.2 用户空间和内核空间

![image-20220306202235244](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306202235244.png)

内核是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也 有访问底层硬件设备的权限。 

内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代 码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中，都是对物理地址的 映射。

在 Linux 系统中, 内核进程和用户进程所占的虚拟内存比例是 1:3

![image-20220306202305476](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220306202305476.png)

当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。 

进程在内核空间以执行任意命令，调用系统的一切资源；在用户空间只能执行简单 的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核 发出指令。

#### 4.4.3 进程切换（上下文切换）

#### 4.4.4 进程的阻塞

#### 4.4.5 文件描述符 FD

#### 4.4.6 传统 I/O 数据拷贝

#### 4.4.7 Blocking I/O

#### 4.4.8 I/O 多路复用（I/O Multiplexing）

## 5.内存回收
### 5.1 过期策略

#### 5.1.1 定时过期（主动淘汰）

#### 5.1.2 惰性过期（被动淘汰）

#### 5.1.3 定期过期

### 5.2 淘汰策略

#### 5.2.1 最大内存设置

#### 5.2.2 淘汰策略

#### 5.2.3 LRU 淘汰原理

#### 5.2.4 LFU

## 6.持久化机制

### 6.1 RDB

#### 6.1.1 RDB 触发

##### 1、自动触发

##### 2、手动触发

#### 6.1.2 RDB 数据的恢复（演示）

1、shutdown 持久化

2、模拟数据丢失

3、通过备份文件恢复数据

#### 6.1.3 RDB 文件的优势和劣势

### 6.2 AOF

#### 6.2.1 AOF 配置

#### 6.2.2 AOF 数据恢复

#### 6.2.3 AOF 优势与劣势

