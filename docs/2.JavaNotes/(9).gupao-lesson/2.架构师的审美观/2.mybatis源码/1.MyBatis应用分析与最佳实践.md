# MyBatis应用分析与最佳实践

## JDBC连接数据库

第一步，注册驱动，获取连接

第二步，通过 DriverManager 获取一个 Connection，参数里 面填数据库地址，用户名和密码。 

第三步，我们通过 Connection 创建一个 Statement 对象。 

第四步，通过 Statement 的 execute()方法执行 SQL。当然 Statement 上面定义了 非常多的方法。execute()方法返回一个 ResultSet 对象，我们把它叫做结果集。 

第五步，我们通过 ResultSet 获取数据。转换成一个 POJO 对象。 最后，我们要关闭数据库相关的资源，包括 ResultSet、Statement、Connection， 它们的关闭顺序和打开的顺序正好是相反的。

## Spring JDBC

```java
public class EmployeeRowMapper implements RowMapper {
    @Override
    public Object mapRow(ResultSet resultSet, int i) throws SQLException {
        Employee employee = new Employee();
        employee.setEmpId(resultSet.getInt("emp_id"));
        employee.setEmpName(resultSet.getString("emp_name"));
        employee.setEmail(resultSet.getString("emial"));
        return employee;
    }
}
```

```java
public List<Employee> query(String sql){
    new JdbcTemplate( new DruidDataSource());
    return jdbcTemplate.query(sql,new EmployeeRowMapper());
}
```

我们可以创建一个 BaseRowMapper，通过反射的方式自动获取所有属性，把 表字段全部赋值到属性。

```java
return jdbcTemplate.query(sql,new BaseRowMapper(Employee.class));
```

## ORM:Object Relational Mapping

![image-20220225222219263](https://gitee.com/forge-logic/images-lib/raw/master/img/image-20220225222219263.png)

### Hibernate（全自动）

问题：

1、不能指定部分字段 

2、无法自定义SQL，优化困难 

3、不支持动态SQL

### Mybatis（半自动）

1、 使用连接池对连接进行管理 

2、 SQL 和代码分离，集中管理 

3、 结果集映射 

4、 参数映射和动态 SQL 

5、 重复 SQL 的提取 

6、 缓存管理 

7、 插件机制

### 如何选择ORM框架

参考： 

1、业务简单的项目可以使用Hibernate

 2、需要灵活的SQL，可以用MyBatis 

3、对性能要求高，可以使用JDBC 

4、Spring JDBC可以和ORM框架混用

## Mybatis编程式开发

### 核心对象的生命周期

> [mybatis – MyBatis 3 | 入门](https://mybatis.org/mybatis-3/zh/getting-started.html)

#### SqlSessionFactoryBuilder
它是用来构建SqlSessionFactory的， 而SqlSessionFactory 只需要一个，所以只要构建了这一个 SqlSessionFactory，它的使命就完成了，也就没有存在的意义了。所以它的生命周期只存在于方法的局部。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。
#### SqlSessionFactory

SqlSessionFactory 是用来创建 SqlSession 的，每次应用程序访问数据库，都需要 创建一个会话。因为我们一直有创建会话的需要，所以 SqlSessionFactory 应该存在于 应用的整个生命周期中（**作用域是应用作用域**）。创建 SqlSession 只需要一个实例来做 这件事就行了，否则会产生很多的混乱，和浪费资源。**所以我们要采用单例模式，最简单的就是使用单例模式或者静态单例模式。**

#### SqlSession
SqlSession 是一个会话，因为它不是线程安全的，不能在线程间共享。所以我们在请求开始的时候创建一个 SqlSession 对象，在请求结束或者说方法执行完毕的时候要及时关闭它（一次请求或者操作中）

#### Mapper

映射器接口(Mapper)的实例是从 SqlSession 中获得的。

```java
BlogMapper mapper = session.getMapper(BlogMapper.class);
```

它的作用是发送 SQL 来操作数据库的数据。它应该在一个 SqlSession 事务方法之 内。任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。

#### 总结

| 对象                      | 生命周期                     |
| ------------------------- | ---------------------------- |
| SqlSessionFactoryBuilder  | 方法局部（method）           |
| SqlSessionFactory（单例） | 应用级别（application）      |
| SqlSession                | 请求和操作（request/method） |
| Mapper                    | 方法（method）               |

### 核心配置解读

> 参考MyBatis配置
>

[Mybatis配置](E:\JavaStudyNote\JavaNotes\docs\2.JavaNotes\(9).gupao-lesson\2.架构师的审美观\1.Spring源码\01.Spring源码核心骗\[mybatis – MyBatis 3 | 配置](https:\mybatis.org\mybatis-3\zh\configuration.html)) 

https://mybatis.org/mybatis-3/zh/configuration.html

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!--全局配置文件-->
<configuration>
    <!-- 参数设置 -->
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
        <!-- 打印查询语句 -->
        <setting name="logImpl" value="STDOUT_LOGGING" />

        <!-- 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。默认 false  -->
        <setting name="lazyLoadingEnabled" value="true"/>
        <!-- 当开启时，任何方法的调用都会加载该对象的所有属性。默认 false，可通过select标签的 fetchType来覆盖-->
        <setting name="aggressiveLazyLoading" value="false"/>
        <!--  Mybatis 创建具有延迟加载能力的对象所用到的代理工具，默认JAVASSIST -->
        <!--<setting name="proxyFactory" value="CGLIB" />-->
    </settings>

    <!-- 类型别名 -->
<!--    <typeAliases>
        <package name="com.gupaoedu.crud.bean"/>
&lt;!&ndash;
        <typeAlias alias="Department" type="com.gupaoedu.crud.bean.Department" />
&ndash;&gt;
    </typeAliases>-->

    <!--分页插件的注册-->
    <plugins>
        <plugin interceptor="com.github.pagehelper.PageInterceptor">
            <!-- 4.0.0以后版本可以不设置该参数 ,可以自动识别
            <property name="dialect" value="mysql"/>  -->
            <!-- 该参数默认为false -->
            <!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 -->
            <!-- 和startPage中的pageNum效果一样-->
            <property name="offsetAsPageNum" value="true"/>
            <!-- 该参数默认为false -->
            <!-- 设置为true时，使用RowBounds分页会进行count查询 -->
            <property name="rowBoundsWithCount" value="true"/>
            <!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 -->
            <!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）-->
            <property name="pageSizeZero" value="true"/>
            <!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 -->
            <!-- 启用合理化时，如果pageNum<1会查询第一页，如果pageNum>pages会查询最后一页 -->
            <!-- 禁用合理化时，如果pageNum<1或pageNum>pages会返回空数据 -->
            <property name="reasonable" value="true"/>
            <!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 -->
            <!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 -->
            <!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,orderBy,不配置映射的用默认值 -->
            <!-- 不理解该含义的前提下，不要随便复制该配置 -->
            <property name="params" value="pageNum=start;pageSize=limit;"/>
            <!-- 支持通过Mapper接口参数来传递分页参数 -->
            <property name="supportMethodsArguments" value="true"/>
            <!-- always总是返回PageInfo类型,check检查返回类型是否为PageInfo,none返回Page -->
            <property name="returnPageInfo" value="check"/>
        </plugin>
    </plugins>
</configuration>
```

### Mapper.xml 映射配置文件

[mybatis – MyBatis 3 | XML 映射器](https://mybatis.org/mybatis-3/zh/sqlmap-xml.html)

https://mybatis.org/mybatis-3/zh/sqlmap-xml.html

- `cache` – 该命名空间的缓存配置。
- `cache-ref` – 引用其它命名空间的缓存配置。
- `resultMap` – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。
- `sql` – 可被其它语句引用的可重用语句块。
- `insert` – 映射插入语句。
- `update` – 映射更新语句。
- `delete` – 映射删除语句。
- `select` – 映射查询语句。

动态SQL配置

<if>

<choose>(<when>,<otherwise>)

<trim>(<where>，<set>)

<foreach>