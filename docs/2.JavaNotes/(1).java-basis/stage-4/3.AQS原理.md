## AQS原理

```java
public class AbstractQueuedSynchronizerDemo {

    private static Lock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        // 一个线程获得锁，另一个线程入队
        executorService.submit(AbstractQueuedSynchronizerDemo::action);
        executorService.submit(AbstractQueuedSynchronizerDemo::action);

        executorService.awaitTermination(200, TimeUnit.SECONDS);

        // 非公平锁
        // thread-1 unlock -> release -> unpark thread-2 -> thread-2 try acquire
        // thread-4 or thread-5 lock -> try acquire

        // PS : unpark = LockSupport.unpark

        // 公平锁
        // thread-1 unlock -> release -> unpark thread-2 -> thread-2 try acquire
        // thread-2 lock -> ..
        // thread-3 wait
        // thread-4 wait
        // thread-5 wait

        // 关闭线程池
        executorService.shutdown();;
    }

    private static void action() {
        System.out.printf("当前线程[%s]正在等待您的输入\n", Thread.currentThread().getName());

        // I/O方式中断线程
        try {
            // 利用ReentrantLock 作为AQS实现，理解内部数据结构
            lock.lock();
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

![image-20210408222521810](https://new-blog-1251602255.cos.ap-shanghai.myqcloud.com/img/image-20210408222521810.png)

